---
description: Next.js App Router, SSR, and performance optimization rules
globs: ["app/**/*", "**/page.tsx", "**/layout.tsx", "**/loading.tsx", "**/error.tsx", "**/not-found.tsx"]
alwaysApply: true
---

# Next.js Rules

## App Router Structure
- Use App Router (app directory) for all new projects
- Follow the file-based routing convention
- Use `page.tsx` for route components
- Use `layout.tsx` for shared layouts
- Use `loading.tsx` for loading states
- Use `error.tsx` for error boundaries
- Use `not-found.tsx` for 404 pages

## Route Organization
```
app/
├── (auth)/          # Route groups
│   ├── login/
│   └── register/
├── dashboard/
│   ├── layout.tsx
│   ├── page.tsx
│   └── settings/
├── api/             # API routes
│   └── users/
└── globals.css
```

## Server Components vs Client Components
- Prefer Server Components by default
- Use `"use client"` directive only when necessary
- Client Components for: interactivity, browser APIs, event handlers, state management

```typescript
// Good: Server Component (default)
export default function HomePage() {
  return <div>Static content</div>;
}

// Good: Client Component when needed
"use client";
import { useState } from 'react';

export default function InteractiveComponent() {
  const [count, setCount] = useState(0);
  return <button onClick={() => setCount(c => c + 1)}>{count}</button>;
}
```

## Data Fetching
- Use `fetch` in Server Components for data fetching
- Implement proper error handling and loading states
- Use `revalidate` for ISR (Incremental Static Regeneration)
- Cache data appropriately with Next.js caching

```typescript
// Good: Server Component data fetching
async function getUsers(): Promise<User[]> {
  const res = await fetch('https://api.example.com/users', {
    next: { revalidate: 3600 } // Cache for 1 hour
  });
  
  if (!res.ok) {
    throw new Error('Failed to fetch users');
  }
  
  return res.json();
}

export default async function UsersPage() {
  const users = await getUsers();
  return <UserList users={users} />;
}
```

## API Routes
- Use App Router API routes (`app/api/`)
- Implement proper HTTP methods and status codes
- Add request validation and error handling
- Use TypeScript for request/response types

```typescript
// app/api/users/route.ts
import { NextRequest, NextResponse } from 'next/server';

export async function GET(request: NextRequest) {
  try {
    const users = await getUsers();
    return NextResponse.json(users);
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to fetch users' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json();
    const user = await createUser(body);
    return NextResponse.json(user, { status: 201 });
  } catch (error) {
    return NextResponse.json(
      { error: 'Failed to create user' },
      { status: 400 }
    );
  }
}
```

## Metadata and SEO
- Use `generateMetadata` for dynamic metadata
- Implement proper Open Graph and Twitter Card meta tags
- Use structured data for better SEO

```typescript
// app/users/[id]/page.tsx
import { Metadata } from 'next';

type Props = {
  params: { id: string };
};

export async function generateMetadata({ params }: Props): Promise<Metadata> {
  const user = await getUser(params.id);
  
  return {
    title: `${user.name} - User Profile`,
    description: `Profile page for ${user.name}`,
    openGraph: {
      title: `${user.name} - User Profile`,
      description: `Profile page for ${user.name}`,
      images: [user.avatar],
    },
  };
}
```

## Performance Optimization
- Use `next/image` for optimized images
- Implement proper loading states
- Use `next/dynamic` for code splitting
- Optimize bundle size with proper imports

```typescript
// Good: Dynamic imports
import dynamic from 'next/dynamic';

const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <p>Loading...</p>,
  ssr: false
});

// Good: Image optimization
import Image from 'next/image';

<Image
  src="/hero.jpg"
  alt="Hero image"
  width={800}
  height={600}
  priority
  placeholder="blur"
  blurDataURL="data:image/jpeg;base64,..."
/>
```

## Middleware
- Use middleware for authentication, redirects, and request modification
- Keep middleware lightweight and fast
- Use `NextResponse` for response modification

```typescript
// middleware.ts
import { NextRequest, NextResponse } from 'next/server';

export function middleware(request: NextRequest) {
  const token = request.cookies.get('auth-token');
  
  if (!token && request.nextUrl.pathname.startsWith('/dashboard')) {
    return NextResponse.redirect(new URL('/login', request.url));
  }
  
  return NextResponse.next();
}

export const config = {
  matcher: ['/dashboard/:path*']
};
```

## Environment Variables
- Use `NEXT_PUBLIC_` prefix for client-side variables
- Keep sensitive variables server-side only
- Use proper validation for environment variables

```typescript
// Good: Environment variable validation
const requiredEnvVars = {
  DATABASE_URL: process.env.DATABASE_URL,
  NEXTAUTH_SECRET: process.env.NEXTAUTH_SECRET,
} as const;

for (const [key, value] of Object.entries(requiredEnvVars)) {
  if (!value) {
    throw new Error(`Missing required environment variable: ${key}`);
  }
}
```

## Error Handling
- Implement error boundaries for graceful error handling
- Use proper error pages and fallbacks
- Log errors appropriately

```typescript
// app/error.tsx
'use client';

export default function Error({
  error,
  reset,
}: {
  error: Error & { digest?: string };
  reset: () => void;
}) {
  return (
    <div>
      <h2>Something went wrong!</h2>
      <button onClick={() => reset()}>Try again</button>
    </div>
  );
}
```