---
description: Tailwind CSS, styling patterns, and design system rules
globs: ["**/*.css", "**/*.tsx", "**/*.jsx", "styles/**/*"]
alwaysApply: true
---

# Styling Rules

## Tailwind CSS Best Practices
- Use utility-first approach with Tailwind CSS
- Define colors using CSS root variables in index.css (preferred over tailwind.config.js)
- Use consistent spacing and sizing scales
- Implement responsive design with mobile-first approach

```css
/* Good: CSS root variables in index.css */
:root {
  --color-primary: #3b82f6;
  --color-primary-dark: #1d4ed8;
  --color-secondary: #64748b;
  --color-accent: #f59e0b;
  --color-background: #ffffff;
  --color-surface: #f8fafc;
  --color-text: #1e293b;
  --color-text-muted: #64748b;
  
  --spacing-xs: 0.25rem;
  --spacing-sm: 0.5rem;
  --spacing-md: 1rem;
  --spacing-lg: 1.5rem;
  --spacing-xl: 2rem;
}
```

## Component Styling Patterns
- Use consistent class naming and organization
- Group related classes together
- Use conditional classes with proper TypeScript typing
- Implement design tokens for consistency

```typescript
// Good: Component with consistent styling
interface ButtonProps {
  variant?: 'primary' | 'secondary' | 'outline';
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}

export function Button({ 
  variant = 'primary', 
  size = 'md', 
  className = '',
  ...props 
}: ButtonProps & React.ButtonHTMLAttributes<HTMLButtonElement>) {
  const baseClasses = 'inline-flex items-center justify-center font-medium rounded-lg transition-colors focus:outline-none focus:ring-2 focus:ring-offset-2';
  
  const variantClasses = {
    primary: 'bg-blue-600 text-white hover:bg-blue-700 focus:ring-blue-500',
    secondary: 'bg-gray-600 text-white hover:bg-gray-700 focus:ring-gray-500',
    outline: 'border border-gray-300 text-gray-700 hover:bg-gray-50 focus:ring-blue-500'
  };
  
  const sizeClasses = {
    sm: 'px-3 py-1.5 text-sm',
    md: 'px-4 py-2 text-base',
    lg: 'px-6 py-3 text-lg'
  };
  
  return (
    <button
      className={cn(
        baseClasses,
        variantClasses[variant],
        sizeClasses[size],
        className
      )}
      {...props}
    />
  );
}
```

## Responsive Design
- Use mobile-first responsive design
- Implement consistent breakpoints
- Use container queries when appropriate
- Test on multiple screen sizes

```typescript
// Good: Responsive component
function ResponsiveGrid({ children }: { children: React.ReactNode }) {
  return (
    <div className="grid grid-cols-1 gap-4 sm:grid-cols-2 md:grid-cols-3 lg:grid-cols-4 xl:grid-cols-5">
      {children}
    </div>
  );
}

// Good: Responsive text
function Heading({ children }: { children: React.ReactNode }) {
  return (
    <h1 className="text-2xl font-bold text-gray-900 sm:text-3xl md:text-4xl lg:text-5xl">
      {children}
    </h1>
  );
}
```

## Dark Mode Support
- Implement proper dark mode with CSS variables
- Use `prefers-color-scheme` for system preference
- Provide manual toggle option
- Test both light and dark themes

```css
/* Good: Dark mode with CSS variables */
:root {
  --color-background: #ffffff;
  --color-surface: #f8fafc;
  --color-text: #1e293b;
  --color-text-muted: #64748b;
}

@media (prefers-color-scheme: dark) {
  :root {
    --color-background: #0f172a;
    --color-surface: #1e293b;
    --color-text: #f1f5f9;
    --color-text-muted: #94a3b8;
  }
}

[data-theme="dark"] {
  --color-background: #0f172a;
  --color-surface: #1e293b;
  --color-text: #f1f5f9;
  --color-text-muted: #94a3b8;
}
```

```typescript
// Good: Dark mode component
function ThemeToggle() {
  const [theme, setTheme] = useState<'light' | 'dark'>('light');
  
  useEffect(() => {
    const savedTheme = localStorage.getItem('theme') as 'light' | 'dark' | null;
    const systemTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light';
    setTheme(savedTheme || systemTheme);
  }, []);
  
  useEffect(() => {
    document.documentElement.setAttribute('data-theme', theme);
    localStorage.setItem('theme', theme);
  }, [theme]);
  
  return (
    <button
      onClick={() => setTheme(prev => prev === 'light' ? 'dark' : 'light')}
      className="p-2 rounded-lg bg-gray-200 dark:bg-gray-700"
    >
      {theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
    </button>
  );
}
```

## Animation and Transitions
- Use consistent transition durations
- Implement smooth animations
- Use CSS transforms for better performance
- Provide reduced motion support

```css
/* Good: Animation utilities */
.transition-base {
  transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
  transition-timing-function: cubic-bezier(0.4, 0, 0.2, 1);
  transition-duration: 150ms;
}

.animate-fade-in {
  animation: fadeIn 0.3s ease-in-out;
}

.animate-slide-up {
  animation: slideUp 0.3s ease-out;
}

@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { transform: translateY(10px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@media (prefers-reduced-motion: reduce) {
  .transition-base,
  .animate-fade-in,
  .animate-slide-up {
    animation: none;
    transition: none;
  }
}
```

## Layout Patterns
- Use CSS Grid for complex layouts
- Use Flexbox for component alignment
- Implement consistent spacing system
- Use semantic HTML structure

```typescript
// Good: Layout components
function Container({ children, className = '' }: { children: React.ReactNode; className?: string }) {
  return (
    <div className={cn('mx-auto max-w-7xl px-4 sm:px-6 lg:px-8', className)}>
      {children}
    </div>
  );
}

function Stack({ 
  children, 
  spacing = 'md', 
  direction = 'vertical',
  className = '' 
}: {
  children: React.ReactNode;
  spacing?: 'sm' | 'md' | 'lg';
  direction?: 'vertical' | 'horizontal';
  className?: string;
}) {
  const spacingClasses = {
    sm: direction === 'vertical' ? 'space-y-2' : 'space-x-2',
    md: direction === 'vertical' ? 'space-y-4' : 'space-x-4',
    lg: direction === 'vertical' ? 'space-y-6' : 'space-x-6'
  };
  
  return (
    <div className={cn(
      direction === 'vertical' ? 'flex flex-col' : 'flex flex-row',
      spacingClasses[spacing],
      className
    )}>
      {children}
    </div>
  );
}
```

## Typography
- Use consistent font families and sizes
- Implement proper line heights and letter spacing
- Use semantic HTML for accessibility
- Create reusable text components

```typescript
// Good: Typography components
interface TextProps {
  variant?: 'h1' | 'h2' | 'h3' | 'h4' | 'body' | 'caption' | 'small';
  className?: string;
  children: React.ReactNode;
}

export function Text({ variant = 'body', className = '', children }: TextProps) {
  const variantClasses = {
    h1: 'text-4xl font-bold leading-tight tracking-tight',
    h2: 'text-3xl font-bold leading-tight tracking-tight',
    h3: 'text-2xl font-semibold leading-snug',
    h4: 'text-xl font-semibold leading-snug',
    body: 'text-base leading-relaxed',
    caption: 'text-sm leading-normal text-gray-600',
    small: 'text-xs leading-normal text-gray-500'
  };
  
  const Component = variant.startsWith('h') ? variant as keyof JSX.IntrinsicElements : 'p';
  
  return (
    <Component className={cn(variantClasses[variant], className)}>
      {children}
    </Component>
  );
}
```

## Accessibility
- Use proper color contrast ratios
- Implement focus indicators
- Use semantic HTML elements
- Test with screen readers

```typescript
// Good: Accessible component
function AccessibleButton({ 
  children, 
  onClick, 
  ariaLabel,
  disabled = false 
}: {
  children: React.ReactNode;
  onClick: () => void;
  ariaLabel: string;
  disabled?: boolean;
}) {
  return (
    <button
      onClick={onClick}
      disabled={disabled}
      aria-label={ariaLabel}
      className="inline-flex items-center justify-center px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-blue-500 disabled:opacity-50 disabled:cursor-not-allowed"
    >
      {children}
    </button>
  );
}
```

## Utility Functions
- Create utility functions for common styling patterns
- Use clsx/cn for conditional classes
- Implement design token system

```typescript
// Good: Utility function for conditional classes
import { clsx, type ClassValue } from 'clsx';
import { twMerge } from 'tailwind-merge';

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs));
}

// Good: Design token utility
export const tokens = {
  colors: {
    primary: 'var(--color-primary)',
    secondary: 'var(--color-secondary)',
    background: 'var(--color-background)',
    surface: 'var(--color-surface)',
    text: 'var(--color-text)',
    textMuted: 'var(--color-text-muted)'
  },
  spacing: {
    xs: 'var(--spacing-xs)',
    sm: 'var(--spacing-sm)',
    md: 'var(--spacing-md)',
    lg: 'var(--spacing-lg)',
    xl: 'var(--spacing-xl)'
  }
} as const;
```